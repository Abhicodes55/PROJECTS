{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/angular-confirmation-popover/src/lib/confirmation-popover-options.provider.ts","../../../projects/angular-confirmation-popover/src/lib/confirmation-popover-window-options.provider.ts","../../../projects/angular-confirmation-popover/src/lib/confirmation-popover-window.component.ts","../../../projects/angular-confirmation-popover/src/lib/confirmation-popover.directive.ts","../../../projects/angular-confirmation-popover/src/lib/focus.directive.ts","../../../projects/angular-confirmation-popover/src/lib/confirmation-popover.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","create","this","confirmText","cancelText","confirmButtonType","cancelButtonType","placement","hideConfirmButton","hideCancelButton","popoverClass","appendToBody","reverseButtonOrder","closeOnOutsideClick","Injectable","ConfirmationPopoverWindowOptions","__","constructor","prototype","__extends","_super","ConfirmationPopoverOptions","ConfirmationPopoverWindowComponent","options","ngAfterViewInit","onAfterViewInit","Component","args","selector","template","ConfirmationPopoverDirective","viewContainerRef","elm","defaultOptions","cfr","renderer","isDisabled","isOpen","isOpenChange","EventEmitter","confirm","cancel","eventListeners","ngOnInit","emit","ngOnChanges","changes","currentValue","showPopover","hidePopover","ngOnDestroy","onConfirm","event","onCancel","togglePopover","popover","onDocumentClick","nativeElement","contains","target","location","_this","setTimeout","listen","positionPopover","options_1","assign","forEach","param","componentFactory","resolveComponentFactory","childInjector","Injector","providers","provide","useValue","createComponent","length","document","body","appendChild","popoverElement","children","positionElements","destroy","fn","Directive","ViewContainerRef","ElementRef","ComponentFactoryResolver","Renderer2","Input","Output","HostListener","FocusDirective","mwlFocus","focus","USER_OPTIONS","InjectionToken","optionsFactory","userOptions","ConfirmationPopoverModule","forRoot","ngModule","useFactory","deps","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable } from '@angular/core';\n\nexport interface ConfirmationPopoverOptionsInterface {\n  /**\n   * The popover title\n   */\n  popoverTitle?: string;\n\n  /**\n   * The popover message\n   */\n  popoverMessage?: string;\n\n  /**\n   * The popover confirmation button text\n   */\n  confirmText?: string;\n\n  /**\n   * The popover cancel button text\n   */\n  cancelText?: string;\n\n  /**\n   * The popover confirm button type e.g. `success`, `danger` etc\n   */\n  confirmButtonType?: string;\n\n  /**\n   * The popover cancel button type  e.g. `success`, `danger` etc\n   */\n  cancelButtonType?: string;\n\n  /**\n   * The popover placement. Can be `top`, `bottom`, `left`, `right`\n   */\n  placement?: string;\n\n  /**\n   * Which button to cancel. Can be either `confirm` or `cancel`\n   */\n  focusButton?: string;\n\n  /**\n   * Whether to hide the confirmation button\n   */\n  hideConfirmButton?: boolean;\n\n  /**\n   * Whether to hide the cancel button\n   */\n  hideCancelButton?: boolean;\n\n  /**\n   * A custom CSS class to be added to the popover\n   */\n  popoverClass?: string;\n\n  /**\n   * Whether to append the popover to the document body\n   */\n  appendToBody?: boolean;\n\n  /**\n   * Swap the order of the confirm and cancel buttons\n   */\n  reverseButtonOrder?: boolean;\n\n  /**\n   * Whether or not the popover should stay open when clicking outside it\n   */\n  closeOnOutsideClick?: boolean;\n}\n\n@Injectable()\nexport class ConfirmationPopoverOptions\n  implements ConfirmationPopoverOptionsInterface {\n  popoverTitle: string;\n  popoverMessage: string;\n  confirmText: string = 'Confirm';\n  cancelText: string = 'Cancel';\n  confirmButtonType: string = 'success';\n  cancelButtonType: string = 'outline-secondary';\n  placement: string = 'top';\n  focusButton: string;\n  hideConfirmButton: boolean = false;\n  hideCancelButton: boolean = false;\n  popoverClass: string = '';\n  appendToBody: boolean = false;\n  reverseButtonOrder: boolean = false;\n  closeOnOutsideClick: boolean = true;\n}\n","import { ConfirmCancelEvent } from './confirmation-popover.directive';\nimport { Injectable, TemplateRef } from '@angular/core';\nimport { ConfirmationPopoverOptions } from './confirmation-popover-options.provider';\n\n/**\n * @internal\n */\n@Injectable()\nexport class ConfirmationPopoverWindowOptions extends ConfirmationPopoverOptions {\n  onConfirm: (event: ConfirmCancelEvent) => void;\n  onCancel: (event: ConfirmCancelEvent) => void;\n  onAfterViewInit: () => void;\n  customTemplate: TemplateRef<any>;\n}\n","import { Component, AfterViewInit } from '@angular/core';\nimport { ConfirmationPopoverWindowOptions } from './confirmation-popover-window-options.provider';\n\n/**\n * @internal\n */\n@Component({\n  selector: 'mwl-confirmation-popover-window',\n  styleUrls: ['./confirmation-popover-window.component.scss'],\n  templateUrl: './confirmation-popover-window.component.html',\n})\nexport class ConfirmationPopoverWindowComponent implements AfterViewInit {\n  constructor(public options: ConfirmationPopoverWindowOptions) {}\n\n  ngAfterViewInit(): void {\n    this.options.onAfterViewInit();\n  }\n}\n","import {\n  Directive,\n  Input,\n  Output,\n  EventEmitter,\n  HostListener,\n  ViewContainerRef,\n  ComponentRef,\n  OnDestroy,\n  ElementRef,\n  OnChanges,\n  OnInit,\n  Injector,\n  ComponentFactoryResolver,\n  Renderer2,\n  TemplateRef,\n  ComponentFactory,\n  SimpleChanges,\n} from '@angular/core';\nimport { ConfirmationPopoverWindowComponent } from './confirmation-popover-window.component';\nimport { ConfirmationPopoverOptions } from './confirmation-popover-options.provider';\nimport { ConfirmationPopoverWindowOptions } from './confirmation-popover-window-options.provider';\nimport { positionElements } from 'positioning';\n\n/**\n * @internal\n */\nexport interface ConfirmCancelEvent {\n  clickEvent: MouseEvent;\n}\n\n/**\n All properties can be set on the directive as attributes like so (use `ConfirmationPopoverModule.forRoot()` to configure them globally):\n ```html\n <button\n   class=\"btn btn-outline-secondary\"\n   mwlConfirmationPopover\n   [popoverTitle]=\"popoverTitle\"\n   [popoverMessage]=\"popoverMessage\"\n   placement=\"left\"\n   (confirm)=\"confirmClicked = true\"\n   (cancel)=\"cancelClicked = true\"\n   [(isOpen)]=\"isOpen\">\n    Show confirm popover!\n  </button>\n  ```\n */\n@Directive({\n  selector: '[mwlConfirmationPopover]',\n})\nexport class ConfirmationPopoverDirective\n  implements OnDestroy, OnChanges, OnInit {\n  /**\n   * The title of the popover\n   */\n  @Input() popoverTitle: string;\n\n  /**\n   * The body text of the popover.\n   */\n  @Input() popoverMessage: string;\n\n  /**\n   * The text of the confirm button. Default `Confirm`\n   */\n  @Input() confirmText: string;\n\n  /**\n   * The text of the cancel button. Default `Cancel`\n   */\n  @Input() cancelText: string;\n\n  /**\n   * The placement of the popover. It can be either `top`, `right`, `bottom` or `left`. Default `top`\n   */\n  @Input() placement: string;\n\n  /**\n   * The bootstrap button type of the confirm button. It can be any supported bootstrap color type\n   * e.g. `default`, `warning`, `danger` etc. Default `success`\n   */\n  @Input() confirmButtonType: string;\n\n  /**\n   * The bootstrap button type of the cancel button. It can be any supported bootstrap color type\n   * e.g. `default`, `warning`, `danger` etc. Default `default`\n   */\n  @Input() cancelButtonType: string;\n\n  /**\n   * Set to either `confirm` or `cancel` to focus the confirm or cancel button.\n   * If omitted, by default it will not focus either button.\n   */\n  @Input() focusButton: string;\n\n  /**\n   * Whether to hide the confirm button. Default `false`.\n   */\n  @Input() hideConfirmButton: boolean;\n\n  /**\n   * Whether to hide the cancel button. Default `false`.\n   */\n  @Input() hideCancelButton: boolean;\n\n  /**\n   * Whether to disable showing the popover. Default `false`.\n   */\n  @Input() isDisabled: boolean = false;\n\n  /**\n   * Will open or show the popover when changed.\n   * Can be sugared with `isOpenChange` to emulate 2-way binding like so `[(isOpen)]=\"isOpen\"`\n   */\n  @Input() isOpen: boolean = false;\n\n  /**\n   * A reference to a <ng-template> tag that if set will override the popovers template. Use like so:\n   * ```html\n   * <ng-template #customTemplate let-options=\"options\">\n   *   <div [class]=\"'popover ' + options.placement\" style=\"display: block\">\n   *     My custom template\n   *   </div>\n   * </ng-template>\n   * ```\n   *\n   * Then pass customTemplate to the mwlConfirmationPopover directive like so `[customTemplate]=\"customTemplate\"`\n   */\n  @Input() customTemplate: TemplateRef<any>;\n\n  /**\n   * Will emit when the popover is opened or closed\n   */\n  @Output() isOpenChange: EventEmitter<boolean> = new EventEmitter(true);\n\n  /**\n   * An expression that is called when the confirm button is clicked.\n   */\n  @Output() confirm: EventEmitter<ConfirmCancelEvent> = new EventEmitter();\n\n  /**\n   * An expression that is called when the cancel button is clicked.\n   */\n  @Output() cancel: EventEmitter<ConfirmCancelEvent> = new EventEmitter();\n\n  /**\n   * A custom CSS class to be added to the popover\n   */\n  @Input() popoverClass: string;\n\n  /**\n   * Append the element to the document body rather than the trigger element\n   */\n  @Input() appendToBody: boolean;\n\n  /**\n   * Swap the order of the confirm and cancel buttons\n   */\n  @Input() reverseButtonOrder: boolean;\n\n  /**\n   * Determines whether or not the popover should stay open even when clicking outside of it\n   */\n  @Input() closeOnOutsideClick: boolean;\n\n  /**\n   * @internal\n   */\n  popover: ComponentRef<ConfirmationPopoverWindowComponent>;\n\n  private eventListeners: (() => void)[] = [];\n\n  /**\n   * @internal\n   */\n  constructor(\n    private viewContainerRef: ViewContainerRef,\n    private elm: ElementRef,\n    private defaultOptions: ConfirmationPopoverOptions,\n    private cfr: ComponentFactoryResolver,\n    private renderer: Renderer2\n  ) {}\n\n  /**\n   * @internal\n   */\n  ngOnInit(): void {\n    this.isOpenChange.emit(false);\n  }\n\n  /**\n   * @internal\n   */\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes.isOpen) {\n      if (changes.isOpen.currentValue === true) {\n        this.showPopover();\n      } else {\n        this.hidePopover();\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  ngOnDestroy() {\n    this.hidePopover();\n  }\n\n  /**\n   * @internal\n   */\n  onConfirm(event: ConfirmCancelEvent) {\n    this.confirm.emit(event);\n    this.hidePopover();\n  }\n\n  /**\n   * @internal\n   */\n  onCancel(event: ConfirmCancelEvent) {\n    this.cancel.emit(event);\n    this.hidePopover();\n  }\n\n  /**\n   * @internal\n   */\n  @HostListener('click')\n  togglePopover(): void {\n    if (!this.popover) {\n      this.showPopover();\n    } else {\n      this.hidePopover();\n    }\n  }\n\n  private onDocumentClick(event: Event): void {\n    const closeOnOutsideClick =\n      typeof this.closeOnOutsideClick !== 'undefined'\n        ? this.closeOnOutsideClick\n        : this.defaultOptions.closeOnOutsideClick;\n    if (\n      this.popover &&\n      !this.elm.nativeElement.contains(event.target) &&\n      !this.popover.location.nativeElement.contains(event.target) &&\n      closeOnOutsideClick\n    ) {\n      this.hidePopover();\n    }\n  }\n\n  private showPopover(): void {\n    if (!this.popover && !this.isDisabled) {\n      // work around for https://github.com/mattlewis92/angular-confirmation-popover/issues/65\n      // otherwise the document click event gets fired after the click event\n      // that triggered the popover to open (no idea why this is so)\n      setTimeout(() => {\n        this.eventListeners = [\n          this.renderer.listen('document', 'click', (event: Event) =>\n            this.onDocumentClick(event)\n          ),\n          this.renderer.listen('document', 'touchend', (event: Event) =>\n            this.onDocumentClick(event)\n          ),\n          this.renderer.listen('window', 'resize', () =>\n            this.positionPopover()\n          ),\n        ];\n      });\n\n      const options = new ConfirmationPopoverWindowOptions();\n      Object.assign(options, this.defaultOptions, {\n        onConfirm: (event: ConfirmCancelEvent): void => {\n          this.onConfirm(event);\n        },\n        onCancel: (event: ConfirmCancelEvent): void => {\n          this.onCancel(event);\n        },\n        onAfterViewInit: (): void => {\n          this.positionPopover();\n        },\n      });\n\n      const optionalParams: (keyof ConfirmationPopoverDirective)[] = [\n        'confirmText',\n        'cancelText',\n        'placement',\n        'confirmButtonType',\n        'cancelButtonType',\n        'focusButton',\n        'hideConfirmButton',\n        'hideCancelButton',\n        'popoverClass',\n        'appendToBody',\n        'customTemplate',\n        'reverseButtonOrder',\n        'popoverTitle',\n        'popoverMessage',\n      ];\n      optionalParams.forEach((param) => {\n        if (typeof this[param] !== 'undefined') {\n          (options as any)[param] = this[param];\n        }\n      });\n\n      const componentFactory: ComponentFactory<ConfirmationPopoverWindowComponent> = this.cfr.resolveComponentFactory(\n        ConfirmationPopoverWindowComponent\n      );\n      const childInjector = Injector.create({\n        providers: [\n          {\n            provide: ConfirmationPopoverWindowOptions,\n            useValue: options,\n          },\n        ],\n      });\n      this.popover = this.viewContainerRef.createComponent(\n        componentFactory,\n        this.viewContainerRef.length,\n        childInjector\n      );\n      if (options.appendToBody) {\n        document.body.appendChild(this.popover.location.nativeElement);\n      }\n      this.isOpenChange.emit(true);\n    }\n  }\n\n  private positionPopover(): void {\n    if (this.popover) {\n      const popoverElement = this.popover.location.nativeElement.children[0];\n      positionElements(\n        this.elm.nativeElement,\n        popoverElement,\n        this.placement || this.defaultOptions.placement,\n        this.appendToBody || this.defaultOptions.appendToBody\n      );\n    }\n  }\n\n  private hidePopover(): void {\n    if (this.popover) {\n      this.popover.destroy();\n      delete this.popover;\n      this.isOpenChange.emit(false);\n      this.eventListeners.forEach((fn) => fn());\n      this.eventListeners = [];\n    }\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChanges,\n} from '@angular/core';\n\n/**\n * A helper directive to focus buttons. You will only need this if using a custom template\n */\n@Directive({\n  selector: '[mwlFocus]',\n})\nexport class FocusDirective implements OnChanges {\n  @Input() mwlFocus: boolean;\n\n  constructor(private elm: ElementRef) {}\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.mwlFocus && this.mwlFocus === true) {\n      this.elm.nativeElement.focus();\n    }\n  }\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ConfirmationPopoverDirective } from './confirmation-popover.directive';\nimport { ConfirmationPopoverWindowComponent } from './confirmation-popover-window.component';\nimport { FocusDirective } from './focus.directive';\nimport {\n  ConfirmationPopoverOptions,\n  ConfirmationPopoverOptionsInterface,\n} from './confirmation-popover-options.provider';\n\nexport const USER_OPTIONS: InjectionToken<string> = new InjectionToken(\n  'confirmation popover user options'\n);\n\nexport function optionsFactory(\n  userOptions: ConfirmationPopoverOptions\n): ConfirmationPopoverOptions {\n  const options = new ConfirmationPopoverOptions();\n  Object.assign(options, userOptions);\n  return options;\n}\n\n@NgModule({\n  declarations: [\n    ConfirmationPopoverDirective,\n    ConfirmationPopoverWindowComponent,\n    FocusDirective,\n  ],\n  imports: [CommonModule],\n  exports: [ConfirmationPopoverDirective, FocusDirective],\n  entryComponents: [ConfirmationPopoverWindowComponent],\n})\nexport class ConfirmationPopoverModule {\n  static forRoot(\n    options: ConfirmationPopoverOptionsInterface = {}\n  ): ModuleWithProviders<ConfirmationPopoverModule> {\n    return {\n      ngModule: ConfirmationPopoverModule,\n      providers: [\n        {\n          provide: USER_OPTIONS,\n          useValue: options,\n        },\n        {\n          provide: ConfirmationPopoverOptions,\n          useFactory: optionsFactory,\n          deps: [USER_OPTIONS],\n        },\n      ],\n    };\n  }\n}\n"]}