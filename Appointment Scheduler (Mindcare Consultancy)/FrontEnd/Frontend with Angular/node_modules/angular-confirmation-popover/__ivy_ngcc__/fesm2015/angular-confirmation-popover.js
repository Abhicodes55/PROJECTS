import { Injectable, Component, EventEmitter, Injector, Directive, ViewContainerRef, ElementRef, ComponentFactoryResolver, Renderer2, Input, Output, HostListener, InjectionToken, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { positionElements } from 'positioning';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function ConfirmationPopoverWindowComponent_ng_template_0_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9)(1, "button", 10);
    ɵngcc0.ɵɵlistener("click", function ConfirmationPopoverWindowComponent_ng_template_0_div_6_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const options_r3 = ɵngcc0.ɵɵnextContext().options; return ɵngcc0.ɵɵresetView(options_r3.onCancel({ clickEvent: $event })); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const options_r3 = ɵngcc0.ɵɵnextContext().options;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap("btn btn-block btn-" + options_r3.cancelButtonType);
    ɵngcc0.ɵɵproperty("mwlFocus", options_r3.focusButton === "cancel")("innerHtml", options_r3.cancelText, ɵngcc0.ɵɵsanitizeHtml);
} }
function ConfirmationPopoverWindowComponent_ng_template_0_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9)(1, "button", 10);
    ɵngcc0.ɵɵlistener("click", function ConfirmationPopoverWindowComponent_ng_template_0_div_7_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const options_r3 = ɵngcc0.ɵɵnextContext().options; return ɵngcc0.ɵɵresetView(options_r3.onConfirm({ clickEvent: $event })); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const options_r3 = ɵngcc0.ɵɵnextContext().options;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap("btn btn-block btn-" + options_r3.confirmButtonType);
    ɵngcc0.ɵɵproperty("mwlFocus", options_r3.focusButton === "confirm")("innerHtml", options_r3.confirmText, ɵngcc0.ɵɵsanitizeHtml);
} }
const _c0 = function (a1, a2, a3, a4) { return ["popover", a1, a2, a3, a4]; };
function ConfirmationPopoverWindowComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelement(1, "div", 3)(2, "h3", 4);
    ɵngcc0.ɵɵelementStart(3, "div", 5);
    ɵngcc0.ɵɵelement(4, "p", 6);
    ɵngcc0.ɵɵelementStart(5, "div", 7);
    ɵngcc0.ɵɵtemplate(6, ConfirmationPopoverWindowComponent_ng_template_0_div_6_Template, 2, 4, "div", 8);
    ɵngcc0.ɵɵtemplate(7, ConfirmationPopoverWindowComponent_ng_template_0_div_7_Template, 2, 4, "div", 8);
    ɵngcc0.ɵɵelementEnd()()();
} if (rf & 2) {
    const options_r3 = ctx.options;
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction4(7, _c0, options_r3.placement, "popover-" + options_r3.placement, "bs-popover-" + options_r3.placement, options_r3.popoverClass));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("innerHTML", options_r3.popoverTitle, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("innerHTML", options_r3.popoverMessage, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("confirm-btns-reversed", options_r3.reverseButtonOrder);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !options_r3.hideCancelButton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !options_r3.hideConfirmButton);
} }
function ConfirmationPopoverWindowComponent_ng_template_2_Template(rf, ctx) { }
const _c1 = function (a0) { return { options: a0 }; };
class ConfirmationPopoverOptions {
    constructor() {
        this.confirmText = 'Confirm';
        this.cancelText = 'Cancel';
        this.confirmButtonType = 'success';
        this.cancelButtonType = 'outline-secondary';
        this.placement = 'top';
        this.hideConfirmButton = false;
        this.hideCancelButton = false;
        this.popoverClass = '';
        this.appendToBody = false;
        this.reverseButtonOrder = false;
        this.closeOnOutsideClick = true;
    }
}
ConfirmationPopoverOptions.ɵfac = function ConfirmationPopoverOptions_Factory(t) { return new (t || ConfirmationPopoverOptions)(); };
ConfirmationPopoverOptions.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ConfirmationPopoverOptions, factory: ConfirmationPopoverOptions.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfirmationPopoverOptions, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @internal
 */
class ConfirmationPopoverWindowOptions extends ConfirmationPopoverOptions {
}
ConfirmationPopoverWindowOptions.ɵfac = /*@__PURE__*/ function () { let ɵConfirmationPopoverWindowOptions_BaseFactory; return function ConfirmationPopoverWindowOptions_Factory(t) { return (ɵConfirmationPopoverWindowOptions_BaseFactory || (ɵConfirmationPopoverWindowOptions_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ConfirmationPopoverWindowOptions)))(t || ConfirmationPopoverWindowOptions); }; }();
ConfirmationPopoverWindowOptions.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ConfirmationPopoverWindowOptions, factory: ConfirmationPopoverWindowOptions.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfirmationPopoverWindowOptions, [{
        type: Injectable
    }], null, null); })();

/**
 * @internal
 */
class ConfirmationPopoverWindowComponent {
    constructor(options) {
        this.options = options;
    }
    ngAfterViewInit() {
        this.options.onAfterViewInit();
    }
}
ConfirmationPopoverWindowComponent.ɵfac = function ConfirmationPopoverWindowComponent_Factory(t) { return new (t || ConfirmationPopoverWindowComponent)(ɵngcc0.ɵɵdirectiveInject(ConfirmationPopoverWindowOptions)); };
ConfirmationPopoverWindowComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ConfirmationPopoverWindowComponent, selectors: [["mwl-confirmation-popover-window"]], decls: 3, vars: 4, consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngClass"], [1, "popover-arrow", "arrow"], [1, "popover-title", "popover-header", 3, "innerHTML"], [1, "popover-content", "popover-body"], [3, "innerHTML"], [1, "confirm-btns"], ["class", "confirm-btn-container", 4, "ngIf"], [1, "confirm-btn-container"], ["type", "button", 3, "mwlFocus", "innerHtml", "click"]], template: function ConfirmationPopoverWindowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ConfirmationPopoverWindowComponent_ng_template_0_Template, 8, 12, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, ConfirmationPopoverWindowComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.options.customTemplate || _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx.options));
    } }, dependencies: function () { return [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, FocusDirective]; }, styles: [".popover[_ngcontent-%COMP%]{display:block}.bs-popover-bottom[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%], .bs-popover-top[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%]{left:50%}.bs-popover-left[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%], .bs-popover-right[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 8px)}.btn[_ngcontent-%COMP%]{transition:none}.confirm-btns[_ngcontent-%COMP%]{display:flex;justify-content:space-around}.confirm-btn-container[_ngcontent-%COMP%]{flex-basis:50%}.confirm-btn-container[_ngcontent-%COMP%]:not(:first-child){margin-left:4px}.confirm-btn-container[_ngcontent-%COMP%]:not(:last-child){margin-right:4px}.confirm-btns-reversed[_ngcontent-%COMP%]{flex-direction:row-reverse}.confirm-btns-reversed[_ngcontent-%COMP%]   .confirm-btn-container[_ngcontent-%COMP%]:not(:first-child){margin-left:0;margin-right:4px}.confirm-btns-reversed[_ngcontent-%COMP%]   .confirm-btn-container[_ngcontent-%COMP%]:not(:last-child){margin-left:4px;margin-right:0}"] });
ConfirmationPopoverWindowComponent.ctorParameters = () => [
    { type: ConfirmationPopoverWindowOptions }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfirmationPopoverWindowComponent, [{
        type: Component,
        args: [{ selector: 'mwl-confirmation-popover-window', template: "<ng-template #defaultTemplate let-options=\"options\">\n  <div\n    [ngClass]=\"[\n      'popover',\n      options.placement,\n      'popover-' + options.placement,\n      'bs-popover-' + options.placement,\n      options.popoverClass\n    ]\"\n  >\n    <div class=\"popover-arrow arrow\"></div>\n    <h3\n      class=\"popover-title popover-header\"\n      [innerHTML]=\"options.popoverTitle\"\n    ></h3>\n    <div class=\"popover-content popover-body\">\n      <p [innerHTML]=\"options.popoverMessage\"></p>\n      <div\n        class=\"confirm-btns\"\n        [class.confirm-btns-reversed]=\"options.reverseButtonOrder\"\n      >\n        <div class=\"confirm-btn-container\" *ngIf=\"!options.hideCancelButton\">\n          <button\n            type=\"button\"\n            [mwlFocus]=\"options.focusButton === 'cancel'\"\n            [class]=\"'btn btn-block btn-' + options.cancelButtonType\"\n            (click)=\"options.onCancel({ clickEvent: $event })\"\n            [innerHtml]=\"options.cancelText\"\n          ></button>\n        </div>\n        <div class=\"confirm-btn-container\" *ngIf=\"!options.hideConfirmButton\">\n          <button\n            type=\"button\"\n            [mwlFocus]=\"options.focusButton === 'confirm'\"\n            [class]=\"'btn btn-block btn-' + options.confirmButtonType\"\n            (click)=\"options.onConfirm({ clickEvent: $event })\"\n            [innerHtml]=\"options.confirmText\"\n          ></button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-template>\n<ng-template\n  [ngTemplateOutlet]=\"options.customTemplate || defaultTemplate\"\n  [ngTemplateOutletContext]=\"{ options: options }\"\n>\n</ng-template>\n", styles: [".popover{display:block}.bs-popover-bottom .arrow,.bs-popover-top .arrow{left:50%}.bs-popover-left .arrow,.bs-popover-right .arrow{top:calc(50% - 8px)}.btn{transition:none}.confirm-btns{display:flex;justify-content:space-around}.confirm-btn-container{flex-basis:50%}.confirm-btn-container:not(:first-child){margin-left:4px}.confirm-btn-container:not(:last-child){margin-right:4px}.confirm-btns-reversed{flex-direction:row-reverse}.confirm-btns-reversed .confirm-btn-container:not(:first-child){margin-left:0;margin-right:4px}.confirm-btns-reversed .confirm-btn-container:not(:last-child){margin-left:4px;margin-right:0}"] }]
    }], function () { return [{ type: ConfirmationPopoverWindowOptions }]; }, null); })();

/**
 All properties can be set on the directive as attributes like so (use `ConfirmationPopoverModule.forRoot()` to configure them globally):
 ```html
 <button
   class="btn btn-outline-secondary"
   mwlConfirmationPopover
   [popoverTitle]="popoverTitle"
   [popoverMessage]="popoverMessage"
   placement="left"
   (confirm)="confirmClicked = true"
   (cancel)="cancelClicked = true"
   [(isOpen)]="isOpen">
    Show confirm popover!
  </button>
  ```
 */
class ConfirmationPopoverDirective {
    /**
     * @internal
     */
    constructor(viewContainerRef, elm, defaultOptions, cfr, renderer) {
        this.viewContainerRef = viewContainerRef;
        this.elm = elm;
        this.defaultOptions = defaultOptions;
        this.cfr = cfr;
        this.renderer = renderer;
        /**
         * Whether to disable showing the popover. Default `false`.
         */
        this.isDisabled = false;
        /**
         * Will open or show the popover when changed.
         * Can be sugared with `isOpenChange` to emulate 2-way binding like so `[(isOpen)]="isOpen"`
         */
        this.isOpen = false;
        /**
         * Will emit when the popover is opened or closed
         */
        this.isOpenChange = new EventEmitter(true);
        /**
         * An expression that is called when the confirm button is clicked.
         */
        this.confirm = new EventEmitter();
        /**
         * An expression that is called when the cancel button is clicked.
         */
        this.cancel = new EventEmitter();
        this.eventListeners = [];
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.isOpenChange.emit(false);
    }
    /**
     * @internal
     */
    ngOnChanges(changes) {
        if (changes.isOpen) {
            if (changes.isOpen.currentValue === true) {
                this.showPopover();
            }
            else {
                this.hidePopover();
            }
        }
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.hidePopover();
    }
    /**
     * @internal
     */
    onConfirm(event) {
        this.confirm.emit(event);
        this.hidePopover();
    }
    /**
     * @internal
     */
    onCancel(event) {
        this.cancel.emit(event);
        this.hidePopover();
    }
    /**
     * @internal
     */
    togglePopover() {
        if (!this.popover) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    onDocumentClick(event) {
        const closeOnOutsideClick = typeof this.closeOnOutsideClick !== 'undefined'
            ? this.closeOnOutsideClick
            : this.defaultOptions.closeOnOutsideClick;
        if (this.popover &&
            !this.elm.nativeElement.contains(event.target) &&
            !this.popover.location.nativeElement.contains(event.target) &&
            closeOnOutsideClick) {
            this.hidePopover();
        }
    }
    showPopover() {
        if (!this.popover && !this.isDisabled) {
            // work around for https://github.com/mattlewis92/angular-confirmation-popover/issues/65
            // otherwise the document click event gets fired after the click event
            // that triggered the popover to open (no idea why this is so)
            setTimeout(() => {
                this.eventListeners = [
                    this.renderer.listen('document', 'click', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('document', 'touchend', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('window', 'resize', () => this.positionPopover()),
                ];
            });
            const options = new ConfirmationPopoverWindowOptions();
            Object.assign(options, this.defaultOptions, {
                onConfirm: (event) => {
                    this.onConfirm(event);
                },
                onCancel: (event) => {
                    this.onCancel(event);
                },
                onAfterViewInit: () => {
                    this.positionPopover();
                },
            });
            const optionalParams = [
                'confirmText',
                'cancelText',
                'placement',
                'confirmButtonType',
                'cancelButtonType',
                'focusButton',
                'hideConfirmButton',
                'hideCancelButton',
                'popoverClass',
                'appendToBody',
                'customTemplate',
                'reverseButtonOrder',
                'popoverTitle',
                'popoverMessage',
            ];
            optionalParams.forEach((param) => {
                if (typeof this[param] !== 'undefined') {
                    options[param] = this[param];
                }
            });
            const componentFactory = this.cfr.resolveComponentFactory(ConfirmationPopoverWindowComponent);
            const childInjector = Injector.create({
                providers: [
                    {
                        provide: ConfirmationPopoverWindowOptions,
                        useValue: options,
                    },
                ],
            });
            this.popover = this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.popover.location.nativeElement);
            }
            this.isOpenChange.emit(true);
        }
    }
    positionPopover() {
        if (this.popover) {
            const popoverElement = this.popover.location.nativeElement.children[0];
            positionElements(this.elm.nativeElement, popoverElement, this.placement || this.defaultOptions.placement, this.appendToBody || this.defaultOptions.appendToBody);
        }
    }
    hidePopover() {
        if (this.popover) {
            this.popover.destroy();
            delete this.popover;
            this.isOpenChange.emit(false);
            this.eventListeners.forEach((fn) => fn());
            this.eventListeners = [];
        }
    }
}
ConfirmationPopoverDirective.ɵfac = function ConfirmationPopoverDirective_Factory(t) { return new (t || ConfirmationPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ConfirmationPopoverOptions), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ConfirmationPopoverDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ConfirmationPopoverDirective, selectors: [["", "mwlConfirmationPopover", ""]], hostBindings: function ConfirmationPopoverDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ConfirmationPopoverDirective_click_HostBindingHandler() { return ctx.togglePopover(); });
    } }, inputs: { isDisabled: "isDisabled", isOpen: "isOpen", popoverTitle: "popoverTitle", popoverMessage: "popoverMessage", confirmText: "confirmText", cancelText: "cancelText", placement: "placement", confirmButtonType: "confirmButtonType", cancelButtonType: "cancelButtonType", focusButton: "focusButton", hideConfirmButton: "hideConfirmButton", hideCancelButton: "hideCancelButton", customTemplate: "customTemplate", popoverClass: "popoverClass", appendToBody: "appendToBody", reverseButtonOrder: "reverseButtonOrder", closeOnOutsideClick: "closeOnOutsideClick" }, outputs: { isOpenChange: "isOpenChange", confirm: "confirm", cancel: "cancel" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ConfirmationPopoverDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: ConfirmationPopoverOptions },
    { type: ComponentFactoryResolver },
    { type: Renderer2 }
];
ConfirmationPopoverDirective.propDecorators = {
    popoverTitle: [{ type: Input }],
    popoverMessage: [{ type: Input }],
    confirmText: [{ type: Input }],
    cancelText: [{ type: Input }],
    placement: [{ type: Input }],
    confirmButtonType: [{ type: Input }],
    cancelButtonType: [{ type: Input }],
    focusButton: [{ type: Input }],
    hideConfirmButton: [{ type: Input }],
    hideCancelButton: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isOpen: [{ type: Input }],
    customTemplate: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }],
    popoverClass: [{ type: Input }],
    appendToBody: [{ type: Input }],
    reverseButtonOrder: [{ type: Input }],
    closeOnOutsideClick: [{ type: Input }],
    togglePopover: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfirmationPopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlConfirmationPopover]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }, { type: ConfirmationPopoverOptions }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Renderer2 }]; }, { isDisabled: [{
            type: Input
        }], isOpen: [{
            type: Input
        }], isOpenChange: [{
            type: Output
        }], confirm: [{
            type: Output
        }], cancel: [{
            type: Output
        }], 
    /**
     * @internal
     */
    togglePopover: [{
            type: HostListener,
            args: ['click']
        }], popoverTitle: [{
            type: Input
        }], popoverMessage: [{
            type: Input
        }], confirmText: [{
            type: Input
        }], cancelText: [{
            type: Input
        }], placement: [{
            type: Input
        }], confirmButtonType: [{
            type: Input
        }], cancelButtonType: [{
            type: Input
        }], focusButton: [{
            type: Input
        }], hideConfirmButton: [{
            type: Input
        }], hideCancelButton: [{
            type: Input
        }], customTemplate: [{
            type: Input
        }], popoverClass: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], reverseButtonOrder: [{
            type: Input
        }], closeOnOutsideClick: [{
            type: Input
        }] }); })();

/**
 * A helper directive to focus buttons. You will only need this if using a custom template
 */
class FocusDirective {
    constructor(elm) {
        this.elm = elm;
    }
    ngOnChanges(changes) {
        if (changes.mwlFocus && this.mwlFocus === true) {
            this.elm.nativeElement.focus();
        }
    }
}
FocusDirective.ɵfac = function FocusDirective_Factory(t) { return new (t || FocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FocusDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FocusDirective, selectors: [["", "mwlFocus", ""]], inputs: { mwlFocus: "mwlFocus" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
FocusDirective.ctorParameters = () => [
    { type: ElementRef }
];
FocusDirective.propDecorators = {
    mwlFocus: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FocusDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlFocus]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { mwlFocus: [{
            type: Input
        }] }); })();

const USER_OPTIONS = new InjectionToken('confirmation popover user options');
function optionsFactory(userOptions) {
    const options = new ConfirmationPopoverOptions();
    Object.assign(options, userOptions);
    return options;
}
class ConfirmationPopoverModule {
    static forRoot(options = {}) {
        return {
            ngModule: ConfirmationPopoverModule,
            providers: [
                {
                    provide: USER_OPTIONS,
                    useValue: options,
                },
                {
                    provide: ConfirmationPopoverOptions,
                    useFactory: optionsFactory,
                    deps: [USER_OPTIONS],
                },
            ],
        };
    }
}
ConfirmationPopoverModule.ɵfac = function ConfirmationPopoverModule_Factory(t) { return new (t || ConfirmationPopoverModule)(); };
ConfirmationPopoverModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ConfirmationPopoverModule });
ConfirmationPopoverModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfirmationPopoverModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ConfirmationPopoverDirective,
                    ConfirmationPopoverWindowComponent,
                    FocusDirective,
                ],
                imports: [CommonModule],
                exports: [ConfirmationPopoverDirective, FocusDirective],
                entryComponents: [ConfirmationPopoverWindowComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ConfirmationPopoverModule, { declarations: function () { return [ConfirmationPopoverDirective, ConfirmationPopoverWindowComponent, FocusDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ConfirmationPopoverDirective, FocusDirective]; } }); })();

/*
 * Public API Surface of angular-confirmation-popover
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ConfirmationPopoverDirective, ConfirmationPopoverModule, FocusDirective, USER_OPTIONS as ɵa, optionsFactory as ɵb, ConfirmationPopoverOptions as ɵc, ConfirmationPopoverWindowComponent as ɵd, ConfirmationPopoverWindowOptions as ɵe };

//# sourceMappingURL=angular-confirmation-popover.js.map